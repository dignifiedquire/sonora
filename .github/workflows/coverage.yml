name: Coverage

on:
  push:
    branches: [main]
  pull_request:

env:
  CARGO_TERM_COLOR: always

jobs:
  rust-coverage:
    name: Rust Coverage
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6
      - uses: dtolnay/rust-toolchain@stable
        with:
          components: llvm-tools-preview
      - uses: Swatinem/rust-cache@v2
      - uses: taiki-e/install-action@cargo-llvm-cov
      - uses: taiki-e/install-action@nextest
      - name: Generate coverage
        run: |
          cargo llvm-cov nextest --workspace --codecov --output-path rust-codecov.json
          cargo llvm-cov report --lcov --output-path rust-lcov.info
      - name: Upload to Codecov
        uses: codecov/codecov-action@v5
        with:
          files: rust-codecov.json
          flags: rust
          token: ${{ secrets.CODECOV_TOKEN }}
          fail_ci_if_error: false
      - name: Upload to Coveralls
        uses: coverallsapp/github-action@v2
        with:
          file: rust-lcov.info
          flag-name: rust
          parallel: true

  cpp-rust-coverage:
    name: C++ FFI Coverage
    runs-on: ubuntu-latest
    # The LLVM profiling runtime must be force-linked (--whole-archive) into
    # the GCC-linked test binary for .profraw generation to work.
    steps:
      - uses: actions/checkout@v6
        with:
          submodules: true
      - uses: dtolnay/rust-toolchain@stable
        with:
          components: llvm-tools-preview
      - uses: Swatinem/rust-cache@v2
      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y meson ninja-build libabsl-dev libprotobuf-dev protobuf-compiler pkg-config
      - name: Build instrumented Rust library
        run: |
          # Build with coverage instrumentation using RUSTFLAGS directly.
          # We avoid cargo-llvm-cov's show-env/report workflow because report
          # searches for executable object files, but sonora-ffi is a staticlib
          # (no executables produced). Instead we use the LLVM tools directly.
          export RUSTFLAGS="-Cinstrument-coverage"
          export LLVM_PROFILE_FILE="$(pwd)/target/sonora-%p-%4m.profraw"
          echo "RUSTFLAGS=$RUSTFLAGS" >> "$GITHUB_ENV"
          echo "LLVM_PROFILE_FILE=$LLVM_PROFILE_FILE" >> "$GITHUB_ENV"
          cargo build --release -p sonora-ffi
      - name: Extract LLVM profiling runtime
        run: |
          # The instrumented libsonora_ffi.a has weak-undefined __llvm_profile_runtime.
          # GCC won't resolve weak symbols from archives, so we extract the LLVM
          # profiling runtime objects into a standalone static library and force-link
          # it via --whole-archive in LDFLAGS.
          SYSROOT=$(rustc --print sysroot)
          HOST=$(rustc -vV | sed -n 's/host: //p')
          PROFILER_RLIB=$(ls "$SYSROOT"/lib/rustlib/"$HOST"/lib/libprofiler_builtins-*.rlib)

          PROFILER_DIR=$(mktemp -d)
          cd "$PROFILER_DIR"
          ar x "$PROFILER_RLIB"
          rm -f *.rmeta lib.rmeta
          # Create a standalone archive that we can --whole-archive link
          ar rcs libllvm_profiler.a *.o
          rm -f *.o
          cd -

          echo "PROFILER_LIB=$PROFILER_DIR/libllvm_profiler.a" >> "$GITHUB_ENV"
      - name: Build C++ with Rust backend and profiling runtime
        working-directory: cpp
        run: |
          # Force-link the LLVM profiling runtime so __llvm_profile_runtime is
          # defined and the atexit handler writes .profraw files.
          export LDFLAGS="-Wl,--whole-archive $PROFILER_LIB -Wl,--no-whole-archive"
          meson setup builddir \
            -Dtests=enabled \
            -Drust-backend=true \
            -Dprefix=${{ github.workspace }}/install
          ninja -C builddir
      - name: Run C++ tests
        working-directory: cpp
        run: |
          # Increase timeout — coverage instrumentation adds overhead
          meson test -C builddir -v --print-errorlogs --timeout-multiplier 4
      - name: Check for profraw files
        run: |
          echo "LLVM_PROFILE_FILE=$LLVM_PROFILE_FILE"
          echo "Looking for .profraw files in target/..."
          find target/ -name '*.profraw' -ls 2>/dev/null || true
          PROFRAW_COUNT=$(find target/ -name '*.profraw' 2>/dev/null | wc -l)
          echo "Found $PROFRAW_COUNT .profraw files"
          if [ "$PROFRAW_COUNT" -eq 0 ]; then
            echo "::warning::No .profraw files found — profiling runtime may not have fired"
            # Also check for profraw files elsewhere
            find /tmp -name '*.profraw' -ls 2>/dev/null | head -5 || true
          fi
      - name: Generate coverage report
        run: |
          # Use LLVM tools directly since cargo-llvm-cov report can't handle
          # staticlib crates (it only searches for executables as object files).
          SYSROOT=$(rustc --print sysroot)
          HOST=$(rustc -vV | sed -n 's/host: //p')
          LLVM_PROFDATA="$SYSROOT/lib/rustlib/$HOST/bin/llvm-profdata"
          LLVM_COV="$SYSROOT/lib/rustlib/$HOST/bin/llvm-cov"

          TEST_BIN=cpp/builddir/tests/apm_unit_tests
          RUST_LIB=target/release/libsonora_ffi.a

          # Diagnostics: check for coverage sections
          echo "=== Coverage sections in test binary ==="
          readelf -S "$TEST_BIN" 2>/dev/null | grep -i "llvm\|cov\|prof" || echo "(none in binary)"
          echo "=== Coverage sections in Rust .a (first 10) ==="
          readelf -S "$RUST_LIB" 2>/dev/null | grep -i "llvm_cov\|llvm_prf" | head -10 || echo "(none in .a)"
          echo "=== GCC link flags used ==="
          grep -r "gcc\|g++" cpp/builddir/build.ninja 2>/dev/null | grep "apm_unit_tests" | head -3 || true

          # Merge profraw files into a single profdata
          $LLVM_PROFDATA merge -sparse target/sonora-*.profraw -o target/sonora.profdata

          # Extract .o files from the Rust static library — these contain
          # the coverage mapping data that GCC's linker may strip from the
          # final executable.
          OBJ_DIR=$(mktemp -d)
          (cd "$OBJ_DIR" && ar x "$OLDPWD/$RUST_LIB")

          # Collect objects that have coverage mapping sections
          COV_OBJECTS=()
          for obj in "$OBJ_DIR"/*.o; do
            if readelf -S "$obj" 2>/dev/null | grep -q "__llvm_covmap"; then
              COV_OBJECTS+=("$obj")
            fi
          done
          echo "Found ${#COV_OBJECTS[@]} objects with coverage data"

          if [ ${#COV_OBJECTS[@]} -eq 0 ]; then
            echo "::error::No objects with coverage data found"
            exit 1
          fi

          # Build -object flags: first object is positional, rest use --object=
          FIRST="${COV_OBJECTS[0]}"
          OBJ_FLAGS=()
          for obj in "${COV_OBJECTS[@]:1}"; do
            OBJ_FLAGS+=("--object=$obj")
          done

          $LLVM_COV export --format=text \
            --instr-profile=target/sonora.profdata \
            --ignore-filename-regex='(\.cargo/registry|rustc/)' \
            "$FIRST" "${OBJ_FLAGS[@]}" > cpp-rust-codecov.json

          $LLVM_COV export --format=lcov \
            --instr-profile=target/sonora.profdata \
            --ignore-filename-regex='(\.cargo/registry|rustc/)' \
            "$FIRST" "${OBJ_FLAGS[@]}" > cpp-rust-lcov.info

          echo "Coverage reports generated successfully"
          rm -rf "$OBJ_DIR"
      - name: Upload to Codecov
        uses: codecov/codecov-action@v5
        with:
          files: cpp-rust-codecov.json
          flags: cpp-ffi
          token: ${{ secrets.CODECOV_TOKEN }}
          fail_ci_if_error: false
      - name: Upload to Coveralls
        uses: coverallsapp/github-action@v2
        with:
          file: cpp-rust-lcov.info
          flag-name: cpp-ffi
          parallel: true

  coveralls-finish:
    name: Coveralls Finish
    needs: [rust-coverage, cpp-rust-coverage]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Finish Coveralls parallel build
        uses: coverallsapp/github-action@v2
        with:
          parallel-finished: true
